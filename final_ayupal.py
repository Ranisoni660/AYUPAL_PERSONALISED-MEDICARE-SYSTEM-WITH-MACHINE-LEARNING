# -*- coding: utf-8 -*-
"""FINAL_AYUPAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nz8Fo9NpM806uV3_8SuqNMcRFEYjOcTP

# **AYUPAL : PERSONALISED MEDICARE SYSTEM WITH MACHINE LEARNING**

**OBJECTIVE**:*To build a machine learning model that will reccomend the medicines, diets according to the given symptoms by the user*

#### **IMPORT NECESSARY LIBRARIES**
"""

# Commented out IPython magic to ensure Python compatibility.
#LOAD DATASETS & LIBRARIES
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#to keep everything in one plane
# %matplotlib inline

#warnings module in Python provides a way to control how warnings handled within a Python script
import warnings
warnings.filterwarnings('ignore')#ignore the warnings

#LOADING THE DATASET INTO DATAFRAME
MED_DATA=pd.read_csv("Training.csv")

"""**DATA INSPECTION (BASIC CHECKING)**"""

MED_DATA.head()#this will print out first five values in default

MED_DATA.tail()

MED_DATA.shape

#prints the no. of rows and columns
print("Number of Rows here are",MED_DATA.shape[0])
print("Number of Columns here are",MED_DATA.shape[1])

MED_DATA['prognosis'].unique()#different types of diseases

"""The different symptoms present are given below"""

print(MED_DATA.columns.to_list())

len(MED_DATA['prognosis'].unique())

MED_DATA.info()

MED_DATA.describe()

MED_DATA.isnull().sum()

MED_DATA.duplicated().any()

"""Duplicacy is present in the dataset

# **DATA VISUALIZATION**
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Count the occurrences of each prognosis
prognosis_counts = MED_DATA['prognosis'].value_counts()

# Plot a bar chart
plt.figure(figsize=(12, 8))
sns.barplot(x=prognosis_counts.index, y=prognosis_counts.values, palette='viridis')
plt.xticks(rotation=90)  # Rotate the x-axis labels for better visibility
plt.title('Prognosis Frequency')
plt.xlabel('Prognosis')
plt.ylabel('Count')
plt.show()

# Pie chart for prognosis distribution
plt.figure(figsize=(12, 12))
prognosis_counts.plot(kind='pie', autopct='%1.1f%%', cmap='Set3', legend=False)
plt.title('Prognosis Distribution')
plt.ylabel('')  # To hide the ylabel
plt.show()

"""# **SPLITTING THE DATA**"""

#train test split
from sklearn.model_selection import train_test_split#it will help to divide the data into multiple variables
from sklearn.preprocessing import LabelEncoder

X= MED_DATA.drop('prognosis',axis=1)
Y= MED_DATA['prognosis']

X

X_train,X_test,Y_train,Y_test= train_test_split(X,Y,test_size=0.3,random_state=20)#this will split the datasets into 4 sets.it will take 70%(0.3) of the input values into X and same throughly

X_train.shape,X_test.shape,Y_train.shape,Y_test.shape

Y

#Y needs to be converted into numpy array for model
#For this we will create a object of label encoder

le = LabelEncoder()
le.fit(Y)
y=le.transform(Y)

y#converted into array

#now do training with X and y
X_train,X_test,Y_train,Y_test= train_test_split(X,Y,test_size=0.3,random_state=20)

"""# **Training**"""

from sklearn.datasets import make_classification
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier,GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import MultinomialNB

from sklearn.metrics import accuracy_score,confusion_matrix
import numpy as np

#create a dictionary to store models
#SVC stands for support vector. it is basically of two types we are using the linear
models = {
    "SVC" : SVC(kernel='linear'),#it draws a hyper plane between both classes
    "RandomForest" : RandomForestClassifier(n_estimators=100,random_state=42),#it tracks a lot of data at a time
    "GradientBoosting" : GradientBoostingClassifier(n_estimators=100,random_state=42),
    "KNeighbors" : KNeighborsClassifier(n_neighbors=5),
    "MultinomialNB" : MultinomialNB()
}

import numpy as np
for model_name,model in models.items():#for both key and values we use item
    #train model
    model.fit(X_train,Y_train)

    #test model
    predictions= model.predict(X_test)

    #calculate accuracy
    accuracy= accuracy_score(Y_test,predictions)

    #calculate confusion matrix
    cm= confusion_matrix(Y_test,predictions)

    print(f"{model_name} accuracy : {accuracy}")
    print(f"{model_name} confusion Matrix : ")
    print(np.array2string(cm, separator=', '))

"""**Every model is giving 100% result as data is finely preprocessed**

#### **SINGLE prediction**
"""

svc = SVC(kernel='linear')
svc.fit(X_train,Y_train)
ypred= svc.predict(X_test)
accuracy_score(Y_test,ypred)

#saving the model
import pickle
pickle.dump(svc,open("svc.pkl",'wb'))#wb is write binary

#load the model to use it
svc= pickle.load(open("svc.pkl",'rb'))#rb is the read binary

X_test

Y_test

#test
print("Predicted label:", svc.predict(X_test.iloc[0].values.reshape(1,-1)))
print("Actual label:",Y_test)

"""## Recommendation System and Prediction

### Load database and use logic for recommendations
"""

#system description
sym_des= pd.read_csv('/content/symtoms_df.csv')
diets = pd.read_csv("diets.csv")
# Load additional datasets
never_do = pd.read_csv("never_do.csv")
disease_commonality = pd.read_csv("disease_commonality.csv")
disease_complications = pd.read_csv("disease_complications.csv")
disease_homemade_solutions = pd.read_csv("disease_homemade_solutions.csv")
disease_possible_reasons = pd.read_csv("disease_possible_reasons.csv")
disease_recovery_time = pd.read_csv("disease_recovery_time.csv")
Final_description = pd.read_csv("Final_description.csv")
Final_precautions = pd.read_csv("Final_precautions.csv")
Final_workouts = pd.read_csv("Final_workouts.csv")
medications = pd.read_csv("medications.csv")

sym_des.head()

# Display the head of each dataset
print("medications head:\n", medications.head(), "\n")
print("diets head:\n", diets.head(), "\n")
print("never_do head:\n", never_do.head(), "\n")
print("disease_commonality head:\n", disease_commonality.head(), "\n")
print("disease_complications head:\n", disease_complications.head(), "\n")
print("disease_homemade_solutions head:\n", disease_homemade_solutions.head(), "\n")
print("disease_possible_reasons head:\n", disease_possible_reasons.head(), "\n")
print("disease_recovery_time head:\n", disease_recovery_time.head(), "\n")
print("Final_description head:\n", Final_description.head(), "\n")
print("Final_precautions head:\n", Final_precautions.head(), "\n")
print("Final_workouts head:\n", Final_workouts.head(), "\n")

"""# Helper Function

The helper function will fetch additional information based on the predicted disease:
"""

# Load the model from the file
with open("svc.pkl", 'rb') as model_file:
    loaded_svc = pickle.load(model_file)

# Example prediction with the loaded model
print("Example Prediction:")
print("Predicted label:", loaded_svc.predict(X_test.iloc[0].values.reshape(1, -1)))
print("Actual label:", Y_test.iloc[0])

# Extract unique symptoms
symptoms = MED_DATA.columns[:-1]  #last column is 'prognosis'
symptoms_dict = {symptom: idx for idx, symptom in enumerate(symptoms)}

print("Symptoms Dictionary:")
print(symptoms_dict)

# Extract unique diseases
unique_diseases = MED_DATA['prognosis'].unique()
diseases_list = {idx: disease for idx, disease in enumerate(unique_diseases)}

print("Diseases List:")
print(diseases_list)

import pandas as pd
import numpy as np
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix
import pickle

# Load your dataset
MED_DATA = pd.read_csv('Training.csv')

# Extract features and target variable
X = MED_DATA.drop('prognosis', axis=1)
Y = MED_DATA['prognosis']

# Encode the target variable
le = LabelEncoder()
le.fit(Y)
Y_encoded = le.transform(Y)

# Train-test split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y_encoded, test_size=0.3, random_state=20)

# Train the SVC model
svc = SVC(kernel='linear')
svc.fit(X_train, Y_train)

# Test the model
ypred = svc.predict(X_test)
accuracy = accuracy_score(Y_test, ypred)
cm = confusion_matrix(Y_test, ypred)

print(f"SVC accuracy: {accuracy}")
print(f"SVC Confusion Matrix:\n{cm}")

# Save the model to a file
with open("svc.pkl", 'wb') as model_file:
    pickle.dump(svc, model_file)

# Load the model from the file
with open("svc.pkl", 'rb') as model_file:
    loaded_svc = pickle.load(model_file)

# Define symptoms dictionary
symptoms_dict = {symptom: idx for idx, symptom in enumerate(X.columns)}

# Load additional datasets
sym_des = pd.read_csv('/content/symtoms_df.csv')
diets = pd.read_csv("diets.csv")
never_do = pd.read_csv("never_do.csv")
disease_commonality = pd.read_csv("disease_commonality.csv")
disease_complications = pd.read_csv("disease_complications.csv")
disease_homemade_solutions = pd.read_csv("disease_homemade_solutions.csv")
disease_possible_reasons = pd.read_csv("disease_possible_reasons.csv")
disease_recovery_time = pd.read_csv("disease_recovery_time.csv")
Final_description = pd.read_csv("Final_description.csv")
Final_precautions = pd.read_csv("Final_precautions.csv")
Final_workouts = pd.read_csv("Final_workouts.csv")
medications = pd.read_csv("medications.csv")

# Helper function to fetch additional information
def helper(dis):
    # Fetch description
    desc = Final_description[Final_description['Disease'] == dis]['Definition']
    desc = " ".join([w for w in desc]) if not desc.empty else "Description not available."

    # Fetch precautions
    pre = Final_precautions[Final_precautions['Disease'] == dis]
    pre_columns = [col for col in pre.columns if 'Precaution' in col]
    pre = [p for p in pre[pre_columns].values[0]] if not pre.empty else []

    # Fetch medications
    med = medications[medications['Disease'] == dis]['Medication']
    med = [m for m in med.values] if not med.empty else []

    # Fetch diet
    die = diets[diets['Disease'] == dis]['Diet']
    die = [d for d in die.values] if not die.empty else []

    # Fetch workouts
    wrkout = Final_workouts[Final_workouts['Disease'] == dis]['Workouts']
    wrkout = [w for w in wrkout.values] if not wrkout.empty else []

    # Fetch additional datasets
    nd = never_do[never_do['Disease'] == dis]['NEVER DO']
    nd = [n for n in nd.values] if not nd.empty else []

    commonality = disease_commonality[disease_commonality['Disease'] == dis]['Commonality']
    commonality = " ".join([c for c in commonality]) if not commonality.empty else "Commonality not available."

    complications = disease_complications[disease_complications['Disease'] == dis]['Complications']
    complications = [c for c in complications.values] if not complications.empty else []

    homemade_solutions = disease_homemade_solutions[disease_homemade_solutions['Disease'] == dis]['Homemade Solutions']
    homemade_solutions = [h for h in homemade_solutions.values] if not homemade_solutions.empty else []

    possible_reasons = disease_possible_reasons[disease_possible_reasons['Disease'] == dis]['Possible Reasons']
    possible_reasons = [r for r in possible_reasons.values] if not possible_reasons.empty else []

    recovery_time = disease_recovery_time[disease_recovery_time['Disease'] == dis]['Recovery Time']
    recovery_time = " ".join([r for r in recovery_time]) if not recovery_time.empty else "Recovery time not available."

    return desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time

# Model Prediction function
def get_predicted_value(patient_symptoms):
    input_vector = np.zeros(len(symptoms_dict))
    for item in patient_symptoms:
        if item in symptoms_dict:
            input_vector[symptoms_dict[item]] = 1
        else:
            print(f"Symptom '{item}' not found in symptoms_dict")

    print("Input vector:", input_vector)

    predicted_index = loaded_svc.predict([input_vector])[0]
    predicted_disease = le.inverse_transform([predicted_index])[0]

    print("Predicted index:", predicted_index)
    print("Predicted disease:", predicted_disease)

    result = helper(predicted_disease)
    return predicted_disease, result

# Diagnose function
def diagnose():
    # Split the user's input into a list of symptoms (assuming they are comma-separated)
    symptoms = input("Enter your symptoms (comma-separated): ")
    user_symptoms = [s.strip() for s in symptoms.split(',')]
    # Remove any extra characters, if any
    user_symptoms = [symptom.strip("[]' ") for symptom in user_symptoms]

    # Predict the disease
    predicted_disease, result = get_predicted_value(user_symptoms)

    # Fetch additional information
    desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time = result

    # Print the results
    print("=================Predicted Disease============")
    print(predicted_disease)
    print("=================Description==================")
    print(desc)
    print("=================Precautions==================")
    for i, p_i in enumerate(pre, start=1):
        print(f"{i} :  {p_i}")
    print("=================Medications==================")
    for i, m_i in enumerate(med, start=len(pre) + 1):
        print(f"{i} :  {m_i}")
    print("=================Diet==================")
    for i, d_i in enumerate(die, start=len(pre) + len(med) + 1):
        print(f"{i} :  {d_i}")
    print("=================Workouts==================")
    for i, w_i in enumerate(wrkout, start=len(pre) + len(med) + len(die) + 1):
        print(f"{i} :  {w_i}")
    print("=================Never Do==================")
    for i, n_i in enumerate(nd, start=len(pre) + len(med) + len(die) + len(wrkout) + 1):
        print(f"{i} :  {n_i}")
    print("=================Commonality==================")
    print(commonality)
    print("=================Complications==================")
    for i, c_i in enumerate(complications, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + 1):
        print(f"{i} :  {c_i}")
    print("=================Homemade Solutions==================")
    for i, h_i in enumerate(homemade_solutions, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + 1):
        print(f"{i} :  {h_i}")
    print("=================Possible Reasons==================")
    for i, r_i in enumerate(possible_reasons, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + len(homemade_solutions) + 1):
        print(f"{i} :  {r_i}")
    print("=================Recovery Time==================")
    print(recovery_time)

#call to the function
diagnose()

diagnose()

diagnose()

diagnose()

diagnose()

# Helper function to fetch additional information
def helper(dis):
    print(f"Fetching information for disease: {dis}")

    # Fetch description
    desc = Final_description[Final_description['Disease'] == dis]['Definition']
    print(f"Description found: {desc}")
    desc = " ".join([w for w in desc]) if not desc.empty else "Description not available."

    # Fetch precautions
    pre = Final_precautions[Final_precautions['Disease'] == dis]
    pre_columns = [col for col in pre.columns if 'Precaution' in col]
    pre = [p for p in pre[pre_columns].values[0]] if not pre.empty else []
    print(f"Precautions found: {pre}")

    # Fetch medications
    med = medications[medications['Disease'] == dis]['Medication']
    med = [m for m in med.values] if not med.empty else []
    print(f"Medications found: {med}")

    # Fetch diet
    die = diets[diets['Disease'] == dis]['Diet']
    die = [d for d in die.values] if not die.empty else []
    print(f"Diet found: {die}")

    # Fetch workouts
    wrkout = Final_workouts[Final_workouts['Disease'] == dis]['Workouts']
    wrkout = [w for w in wrkout.values] if not wrkout.empty else []
    print(f"Workouts found: {wrkout}")

    # Fetch additional datasets
    nd = never_do[never_do['Disease'] == dis]['NEVER DO']
    nd = [n for n in nd.values] if not nd.empty else []
    print(f"Never Do found: {nd}")

    commonality = disease_commonality[disease_commonality['Disease'] == dis]['Commonality']
    commonality = " ".join([c for c in commonality]) if not commonality.empty else "Commonality not available."
    print(f"Commonality found: {commonality}")

    complications = disease_complications[disease_complications['Disease'] == dis]['Complications']
    complications = [c for c in complications.values] if not complications.empty else []
    print(f"Complications found: {complications}")

    homemade_solutions = disease_homemade_solutions[disease_homemade_solutions['Disease'] == dis]['Homemade Solutions']
    homemade_solutions = [h for h in homemade_solutions.values] if not homemade_solutions.empty else []
    print(f"Homemade Solutions found: {homemade_solutions}")

    possible_reasons = disease_possible_reasons[disease_possible_reasons['Disease'] == dis]['Possible Reasons']
    possible_reasons = [r for r in possible_reasons.values] if not possible_reasons.empty else []
    print(f"Possible Reasons found: {possible_reasons}")

    recovery_time = disease_recovery_time[disease_recovery_time['Disease'] == dis]['Recovery Time']
    recovery_time = " ".join([r for r in recovery_time]) if not recovery_time.empty else "Recovery time not available."
    print(f"Recovery Time found: {recovery_time}")

    return desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time

# Model Prediction function with correction step
def get_predicted_value(patient_symptoms):
    input_vector = np.zeros(len(symptoms_dict))
    unrecognized_symptoms = []
    for item in patient_symptoms:
        if item in symptoms_dict:
            input_vector[symptoms_dict[item]] = 1
        else:
            unrecognized_symptoms.append(item)

    if unrecognized_symptoms:
        print(f"Unrecognized symptoms: {', '.join(unrecognized_symptoms)}")

    print("Input vector:", input_vector)

    predicted_index = loaded_svc.predict([input_vector])[0]
    predicted_disease = le.inverse_transform([predicted_index])[0]

    # Correct known typos or mismatches
    correction_dict = {
        "Peptic ulcer diseae": "Peptic ulcer disease"
    }

    if predicted_disease in correction_dict:
        predicted_disease = correction_dict[predicted_disease]

    print("Predicted index:", predicted_index)
    print("Predicted disease:", predicted_disease)

    result = helper(predicted_disease)
    return predicted_disease, result

# Diagnose function
def diagnose():
    # Split the user's input into a list of symptoms (assuming they are comma-separated)
    symptoms = input("Enter your symptoms (comma-separated): ")
    user_symptoms = [s.strip() for s in symptoms.split(',')]
    # Remove any extra characters, if any
    user_symptoms = [symptom.strip("[]' ") for symptom in user_symptoms]

    # Predict the disease
    predicted_disease, result = get_predicted_value(user_symptoms)

    # Fetch additional information
    desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time = result

    # Print the results
    print("=================Predicted Disease============")
    print(predicted_disease)
    print("=================Description==================")
    print(desc)
    print("=================Precautions==================")
    for i, p_i in enumerate(pre, start=1):
        print(f"{i} :  {p_i}")
    print("=================Medications==================")
    for i, m_i in enumerate(med, start=len(pre) + 1):
        print(f"{i} :  {m_i}")
    print("=================Diet==================")
    for i, d_i in enumerate(die, start=len(pre) + len(med) + 1):
        print(f"{i} :  {d_i}")
    print("=================Workouts==================")
    for i, w_i in enumerate(wrkout, start=len(pre) + len(med) + len(die) + 1):
        print(f"{i} :  {w_i}")
    print("=================Never Do==================")
    for i, n_i in enumerate(nd, start=len(pre) + len(med) + len(die) + len(wrkout) + 1):
        print(f"{i} :  {n_i}")
    print("=================Commonality==================")
    print(commonality)
    print("=================Complications==================")
    for i, c_i in enumerate(complications, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + 1):
        print(f"{i} :  {c_i}")
    print("=================Homemade Solutions==================")
    for i, h_i in enumerate(homemade_solutions, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + 1):
        print(f"{i} :  {h_i}")
    print("=================Possible Reasons==================")
    for i, r_i in enumerate(possible_reasons, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + len(homemade_solutions) + 1):
        print(f"{i} :  {r_i}")
    print("=================Recovery Time==================")
    print(recovery_time)

# Example call to the function
diagnose()

"""# **FINAL FUNCTION**"""

import pandas as pd
import numpy as np
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix
import pickle

# Load your dataset
MED_DATA = pd.read_csv('Training.csv')

# Extract features and target variable
X = MED_DATA.drop('prognosis', axis=1)
Y = MED_DATA['prognosis']

# Encode the target variable
le = LabelEncoder()
le.fit(Y)
Y_encoded = le.transform(Y)

# Train-test split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y_encoded, test_size=0.3, random_state=20)

# Train the SVC model
svc = SVC(kernel='linear')
svc.fit(X_train, Y_train)

# Test the model
ypred = svc.predict(X_test)
accuracy = accuracy_score(Y_test, ypred)
cm = confusion_matrix(Y_test, ypred)

print(f"SVC accuracy: {accuracy}")
print(f"SVC Confusion Matrix:\n{cm}")

# Save the model to a file
with open("svc.pkl", 'wb') as model_file:
    pickle.dump(svc, model_file)

# Load the model from the file
with open("svc.pkl", 'rb') as model_file:
    loaded_svc = pickle.load(model_file)

# Define symptoms dictionary
symptoms_dict = {symptom: idx for idx, symptom in enumerate(X.columns)}

# Load additional datasets
sym_des = pd.read_csv('/content/symtoms_df.csv')
diets = pd.read_csv("diets.csv")
never_do = pd.read_csv("never_do.csv")
disease_commonality = pd.read_csv("disease_commonality.csv")
disease_complications = pd.read_csv("disease_complications.csv")
disease_homemade_solutions = pd.read_csv("disease_homemade_solutions.csv")
disease_possible_reasons = pd.read_csv("disease_possible_reasons.csv")
disease_recovery_time = pd.read_csv("disease_recovery_time.csv")
Final_description = pd.read_csv("Final_description.csv")
Final_precautions = pd.read_csv("Final_precautions.csv")
Final_workouts = pd.read_csv("Final_workouts.csv")
medications = pd.read_csv("medications.csv")

# Helper function to fetch additional information
def helper(dis):
    print(f"Fetching information for disease: {dis}")

    # Fetch description
    desc = Final_description[Final_description['Disease'] == dis]['Definition']
    desc = " ".join([w for w in desc]) if not desc.empty else "Description not available."

    # Fetch precautions
    pre = Final_precautions[Final_precautions['Disease'] == dis]
    pre_columns = [col for col in pre.columns if 'Precaution' in col]
    pre = [p for p in pre[pre_columns].values[0]] if not pre.empty else []

    # Fetch medications
    med = medications[medications['Disease'] == dis]['Medication']
    med = [m for m in med.values] if not med.empty else []

    # Fetch diet
    die = diets[diets['Disease'] == dis]['Diet']
    die = [d for d in die.values] if not die.empty else []

    # Fetch workouts
    wrkout = Final_workouts[Final_workouts['Disease'] == dis]['Workouts']
    wrkout = [w for w in wrkout.values] if not wrkout.empty else []

    # Fetch additional datasets
    nd = never_do[never_do['Disease'] == dis]['NEVER DO']
    nd = [n for n in nd.values] if not nd.empty else []

    commonality = disease_commonality[disease_commonality['Disease'] == dis]['Commonality']
    commonality = " ".join([c for c in commonality]) if not commonality.empty else "Commonality not available."

    complications = disease_complications[disease_complications['Disease'] == dis]['Complications']
    complications = [c for c in complications.values] if not complications.empty else []

    homemade_solutions = disease_homemade_solutions[disease_homemade_solutions['Disease'] == dis]['Homemade Solutions']
    homemade_solutions = [h for h in homemade_solutions.values] if not homemade_solutions.empty else []

    possible_reasons = disease_possible_reasons[disease_possible_reasons['Disease'] == dis]['Possible Reasons']
    possible_reasons = [r for r in possible_reasons.values] if not possible_reasons.empty else []

    recovery_time = disease_recovery_time[disease_recovery_time['Disease'] == dis]['Recovery Time']
    recovery_time = " ".join([r for r in recovery_time]) if not recovery_time.empty else "Recovery time not available."

    return desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time

# Model Prediction function with correction step
def get_predicted_value(patient_symptoms):
    input_vector = np.zeros(len(symptoms_dict))
    for item in patient_symptoms:
        if item in symptoms_dict:
            input_vector[symptoms_dict[item]] = 1
        else:
            print(f"Symptom '{item}' not found in symptoms_dict")

    print("Input vector:", input_vector)

    predicted_index = loaded_svc.predict([input_vector])[0]
    predicted_disease = le.inverse_transform([predicted_index])[0]

    # Correct known typos or mismatches
    correction_dict = {
        "Peptic ulcer diseae": "Peptic ulcer disease",
        "Osteoarthristis": "Osteoarthritis",
        "Hypertension ": "Hypertension",
        "hepatitis A": "Hepatitis A",
        "Dimorphic hemmorhoids(piles)": "Dimorphic hemorrhoids (piles)",
        "Diabetes ": "Diabetes",
        "(vertigo) Paroymsal  Positional Vertigo": "(vertigo) Paroxysmal Positional Vertigo"
    }

    if predicted_disease in correction_dict:
        predicted_disease = correction_dict[predicted_disease]

    print("Predicted index:", predicted_index)
    print("Predicted disease:", predicted_disease)

    result = helper(predicted_disease)
    return predicted_disease, result

# Diagnose function
def diagnose():
    # Split the user's input into a list of symptoms (assuming they are comma-separated)
    symptoms = input("Enter your symptoms (comma-separated): ")
    user_symptoms = [s.strip() for s in symptoms.split(',')]
    # Remove any extra characters, if any
    user_symptoms = [symptom.strip("[]' ") for symptom in user_symptoms]

    # Predict the disease
    predicted_disease, result = get_predicted_value(user_symptoms)

    # Fetch additional information
    desc, pre, med, die, wrkout, nd, commonality, complications, homemade_solutions, possible_reasons, recovery_time = result

    # Print the results
    print("=================Predicted Disease============")
    print(predicted_disease)
    print("=================Description==================")
    print(desc)
    print("=================Precautions==================")
    for i, p_i in enumerate(pre, start=1):
        print(f"{i} :  {p_i}")
    print("=================Medications==================")
    for i, m_i in enumerate(med, start=len(pre) + 1):
        print(f"{i} :  {m_i}")
    print("=================Diet==================")
    for i, d_i in enumerate(die, start=len(pre) + len(med) + 1):
        print(f"{i} :  {d_i}")
    print("=================Workouts==================")
    for i, w_i in enumerate(wrkout, start=len(pre) + len(med) + len(die) + 1):
        print(f"{i} :  {w_i}")
    print("=================Never Do==================")
    for i, n_i in enumerate(nd, start=len(pre) + len(med) + len(die) + len(wrkout) + 1):
        print(f"{i} :  {n_i}")
    print("=================Commonality==================")
    print(commonality)
    print("=================Complications==================")
    for i, c_i in enumerate(complications, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + 1):
        print(f"{i} :  {c_i}")
    print("=================Homemade Solutions==================")
    for i, h_i in enumerate(homemade_solutions, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + 1):
        print(f"{i} :  {h_i}")
    print("=================Possible Reasons==================")
    for i, r_i in enumerate(possible_reasons, start=len(pre) + len(med) + len(die) + len(wrkout) + len(nd) + len(complications) + len(homemade_solutions) + 1):
        print(f"{i} :  {r_i}")
    print("=================Recovery Time==================")
    print(recovery_time)

# Example call to the function
diagnose()

"""### FINDING MORE TYPO ERRORS IN DISEASE NAMES"""

data1=pd.read_csv('Training.csv')
data2=pd.read_csv('/content/disease_recovery_time.csv')

diseases_data1 = data1['prognosis'].unique()
diseases_data2 = data2['Disease'].unique()

only_in_data1 = set(diseases_data1) - set(diseases_data2)
only_in_data2 = set(diseases_data2) - set(diseases_data1)

print("Diseases only in Training.csv:")
print(only_in_data1)

print("\nDiseases only in disease_recovery_time.csv:")
print(only_in_data2)